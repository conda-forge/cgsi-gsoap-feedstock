From f7049fd37df1b876e66214c3ba32dbd4267d4575 Mon Sep 17 00:00:00 2001
From: Chris Burr <christopher.burr@cern.ch>
Date: Wed, 18 May 2022 13:32:33 +0200
Subject: [PATCH] Ignore empty TLS records in cgsi_plugin_recv

When using TLS 1.3 (or TLS 1.2 with the RFC 5077 extension) NewSessionTicket
records may be sent after the initial handshake. This causes the previous
implementation of cgsi_plugin_recv to return an empty response causing gsoap
to think an error ocurred.

Instead, loop in cgsi_plugin_recv until either an error occurs or a non-empty
result is found.
---
 src/cgsi_plugin.c | 110 ++++++++++++++++++++++++----------------------
 1 file changed, 57 insertions(+), 53 deletions(-)

diff --git a/src/cgsi_plugin.c b/src/cgsi_plugin.c
index 48c78fb..3aa6530 100755
--- a/src/cgsi_plugin.c
+++ b/src/cgsi_plugin.c
@@ -1604,68 +1604,72 @@ static size_t cgsi_plugin_recv(struct soap *soap, char *buf, size_t len, const c
             return (size_t) tmplen;
         }
 
+    while (1) {
+        token_status = cgsi_plugin_recv_token((void *)soap,
+                                            &input_token->value,
+                                            &input_token->length);
 
-    token_status = cgsi_plugin_recv_token((void *)soap,
-                                          &input_token->value,
-                                          &input_token->length);
-
-    if (token_status != 0)
-        {
-            trace(data, "Token status <> 0\n");
-            /* Soap fault already reported */
-            return 0;
-        }
-
-    if (data->context_handle != GSS_C_NO_CONTEXT)
-        {
-            ERR_clear_error();
-            major_status = gss_unwrap(&minor_status,
-                                      data->context_handle,
-                                      input_token,
-                                      output_token,
-                                      NULL,
-                                      NULL);
+        if (token_status != 0)
+            {
+                trace(data, "Token status <> 0\n");
+                /* Soap fault already reported */
+                return 0;
+            }
 
-            gss_release_buffer(&minor_status1,
-                               input_token);
-        }
-    else
-        {
-            /* we don't expect to asked to read without a security context.
-             * Best not to read anything which may or may not be wrapped,
-             * so we just fail. Assume a useful fault message has already seen set */
-            trace(data, "Request to read data, without having a security context, failed\n");
-            return (0);
-        }
+        if (data->context_handle != GSS_C_NO_CONTEXT)
+            {
+                ERR_clear_error();
+                major_status = gss_unwrap(&minor_status,
+                                        data->context_handle,
+                                        input_token,
+                                        output_token,
+                                        NULL,
+                                        NULL);
+
+                gss_release_buffer(&minor_status1,
+                                input_token);
+            }
+        else
+            {
+                /* we don't expect to asked to read without a security context.
+                * Best not to read anything which may or may not be wrapped,
+                * so we just fail. Assume a useful fault message has already seen set */
+                trace(data, "Request to read data, without having a security context, failed\n");
+                return (0);
+            }
 
-    if (major_status != GSS_S_COMPLETE)
-        {
-            cgsi_gssapi_err(soap,
-                            "Error unwrapping the data",
-                            major_status,
-                            minor_status);
-            gss_release_buffer(&minor_status1,
-                               output_token);
-            return 0;
-        }
+        if (major_status != GSS_S_COMPLETE)
+            {
+                cgsi_gssapi_err(soap,
+                                "Error unwrapping the data",
+                                major_status,
+                                minor_status);
+                gss_release_buffer(&minor_status1,
+                                output_token);
+                return 0;
+            }
 
-    tmplen = len < output_token->length ? len : output_token->length;
+        tmplen = len < output_token->length ? len : output_token->length;
 
-    memcpy(buf, output_token->value, tmplen);
+        memcpy(buf, output_token->value, tmplen);
 
-    if( tmplen < output_token->length)
-        {
-            data->buffered_in = buffer_create(output_token, tmplen);
-        }
+        if( tmplen < output_token->length)
+            {
+                data->buffered_in = buffer_create(output_token, tmplen);
+            }
 
-    gss_release_buffer(&minor_status1,
-                       output_token);
+        gss_release_buffer(&minor_status1,
+                        output_token);
 
-    trace(data, "<Receiving SOAP Packet>-------------\n");
-    trace_str(data, buf, tmplen);
-    trace(data, "\n----------------------------------\n");
+        if (tmplen > 0) {
+            trace(data, "<Receiving SOAP Packet>-------------\n");
+            trace_str(data, buf, tmplen);
+            trace(data, "\n----------------------------------\n");
 
-    return (size_t) tmplen;
+            return (size_t) tmplen;
+        }
+        trace(data, "Packet is empty, likely a NewSessionTicket, looping...\n");
+    }
 }
 
 
-- 
2.36.0

